}
result <- list(GraphAD=c1o2$deviation, VertexAD=c1o2v)
return(result)
}else if(method=="MASE"){
#Initialize moving averages and moving standard deviation for GraphAD and VerticesAD
mean2 <- rep(1,(tmax-1)-(l-1))
std2 <- rep(1,(tmax-1)-(l-1))
mean2v <- rep(1,(tmax-1)-(l-1))
std2v <- rep(1,(tmax-1)-(l-1))
if(par){
require(doParallel)
cl <- makeCluster(numpar)
registerDoParallel(cl)
clusterEvalQ(cl, source("cleanutilAD.R"))
clusterExport(cl = cl, varlist = list("ase", "getElbows", "glist",
"elbow", "d","approx", "diag.augment","attrweight"), envir = environment())
out <- foreach(i =1:tmax, .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
latpos <- ase(get.adjacency(glist[[i]], attr=attrweight), d=d, diagaug=diag.augment, approx=approx,elbow=elbow)$Xhat
list(latpos, dim(latpos)[2])
}
stopCluster(cl)
} else {
registerDoSEQ()
out <- foreach(i =1:tmax, .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
latpos <- ase(get.adjacency(glist[[i]], attr=attrweight), d=d, diagaug=diag.augment, approx=approx,elbow=elbow)$Xhat
list(latpos, dim(latpos)[2])
}
}
latpos.list <- out[[1]]
dvec <- unlist(out[[2]])
out2 <- doMase(glist,latpos.list, 2, dsvd, attrweight)
for (w in 1:(tmax-1-(l-1))) {
#Iterative calulating moving averages and moving deviations
mase2v <- t(matrix(out2$pdist[,(w):(w+(l-2))],n,l-1))
mean2v[w] <- mean(mase2v)
std2v[w] <- sd.xbar(mase2v, rep(n,l-1), "UWAVE-SD")
mase2 <- matrix(out2$tnorm[((w):(w+l-2))], l-1, 1)
mean2[w] <- mean(mase2)
std2[w] <- sd.xbar.one(mase2, rep(1,l-1), "MR")
}
df <- out2$pdist
mase2v <- matrix(df, tmax-1, n, byrow = TRUE)
c1m2v <- list()
for (i in l:(tmax-1)) {
c1m2v[[i-l+1]] <- qcc(mase2v[i,],type = "xbar.one",center = mean2v[i-l+1],std.dev = std2v[i-l+1], nsigmas=3, plot=FALSE)
}
df <- out2$tnorm
mase2 <- matrix(df, tmax-1, 1)
c1m2 <- qcc(mase2[l:(tmax-1)],type = "xbar.one",center = mean2 ,std.dev = std2, nsigmas=3, plot=FALSE)
if(plot.figure){
print(plot.qcc(c1m2,title="Control Chart MASE", l=l))
print(plot.qcc.vertex(c1m2v, l=l,title="Control Chart MASE"))
}
c1m2v <- list()
for (i in l:(tmax-1)) {
c1m2v[[i-l+1]] <- qcc(mase2v[i,],type = "xbar.one",center = mean2v[i-l+1],std.dev = std2v[i-l+1], nsigmas=3, plot=FALSE)$violations$beyond.limits
}
result <- list(GraphAD=c1m2$deviation, VertexAD=c1m2v)
return(result)
}
}
glist <- list()
for (i in 1:5) {
glist[[i]] <- sample_gnp(100,.1)
}
glist[[6]] <- sample_gnp(100,.6)
glist[[7]] <- sample_gnp(100,.3)
for (i in 8:12) {
glist[[i]] <- sample_gnp(100,.1)
}
l=4
d=1
dsvd=1
result<- qccAD(glist, method="OMNI", diag.augment = TRUE, l,d, dsvd, approx=FALSE, par=FALSE, numpar=2)
source("cleanutilAD.R")
#' Function to perform anomaly detection for time series of graphs
#' @param glist: a list of undirected simple graphs (simple graphs are graphs which do not contain self-loop and multiple edges)
#' in igraph format with same number of vertices with vertices are 1-1 matched.
#' Graphs can be weighted or binary. (Say the length of list to be tmax)
#' @param method: A character variable  to be chosen among c("OMNI","MASE"). The code will first do OMNIbus embedding (OMNI) or Multiple Adjacency Spectrally Ebedding (MASE) with two adjcaency matrices(can be weighted or not) of all input adjacent graphs sequentially. Then use latent positions to calculate test statistics y^{t}=||X^{t}- X^{t+1}|| using operator norm. Then for t=l,...,tmax-1, we calculate the moving means $mu^t$ and moving standard deviations $simgma^t$ at t by y^{t-l+1},...,y^{t-1}.
#' @param d: A fixed integer of dimension to perform OMNI and individual ASE for MASE.  If d is NULL, then dimension is chosen automatically.
#' @param l: An integer of the number of graphs in time window in estimating the moving mean and moving standard deviation. If l is greater or equal than number of graphs then it outputs an error. l has to be strictly greater than 3.
#' @param approx: A Boolean variable approx to decide whether to use irlba package to perform svd. Default is TRUE.
#' @param diag.augment: A Boolean variable diag.augment to decide whether to do diagonal augmentation when performing adjacency spectral embedding. Default is TRUE.
#' @param par: A Boolean variable par to decide whether to run in parallel. Default is FALSE.
#' @param numpar: An integer number to decide number of clusters for parallel implmentation. Default is 2.
#' @param dsvd: An integer number of dimension only used in joint embedding for MASE. If NULL, then dimension is chosen automatically as second elbow selected in Zhu & Ghodsi method for the scree plot of the singular values of the concatenated spectral embeddings of MASE.
#' @param elbow: number of elbow in Zhu & Ghodsi method for the scree plot of each individual graph singular values for MASE or of each omnibus matrix singular values for OMNI.
#' @param plot.figure: A Boolean variable to decide whether plot control chart. Default is TRUE.
#' @return A list containing a vector GraphAD of length tmax-l which consists of control charts deviations, with the
#' a list VertexAD (length tmax-l) with vectors of anomalous vertices indices for each graph.
qccAD <- function(glist, method="OMNI", diag.augment = TRUE, l,d, dsvd, approx=TRUE, par=FALSE, numpar=2, elbow=2, plot.figure=TRUE){
tmax <- length(glist)
n <- vcount(glist[[1]])
tvec <- 1:tmax
m2 <- names(running(tvec, width=2))
#check if all the graphs are binary
if(Reduce("+",lapply(glist, function(x) is.weighted(x)))){
attrweight <- "weight"
}else{
attrweight <- NULL
}
if(l>(tmax-1)||l<3||tmax<4){
print(paste0("l has to an integer between 3 and ",tmax-1, " and you need to at least have 4 graphs"))
}
require(foreach)
if (method=="OMNI"){
#Initialize moving averages and moving standard deviation for GraphAD and VerticesAD
mean2omni <- rep(1, (tmax-1)-(l-1))
std2omni <- rep(1,(tmax-1)-(l-1))
mean2vomni <- rep(1, (tmax-1)-(l-1))
std2vomni <- rep(1,(tmax-1)-(l-1))
if(par){
require(doParallel)
cl <- makeCluster(numpar)
registerDoParallel(cl)
clusterEvalQ(cl, source("cleanutilAD.R"))
clusterExport(cl = cl, varlist = list("ase", "fast2buildOmni", "getElbows", "glist",
"elbow", "d","approx", "diag.augment","attrweight"), envir = environment())
allomni <- foreach(i =1:(tmax-1), .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
O <- fast2buildOmni( glist[i:(i+1)]  , diagaug=diag.augment, attrweight=attrweight)
a <- ase(O, d=d, diagaug=FALSE, approx=approx,elbow=elbow)
list(a, a$d)
}
stopCluster(cl)
} else {
registerDoSEQ()
allomni <- foreach(i =1:(tmax-1), .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
O <- fast2buildOmni( glist[i:(i+1)]  , diagaug=diag.augment, attrweight=attrweight)
a <- ase(O, d=d, diagaug=FALSE, approx=approx,elbow=elbow)
list(a, a$d)
}
}
a = allomni[[1]]
out2omni <- fast2doOmni(glist, omniase=a)
for (w in 1:(tmax-1-(l-1))) {
#Iterative calulating moving averages and moving deviations
omni2v <- t(out2omni$pdist[,(w):(w+(l-2))])
mean2vomni[w] <- mean(omni2v)
std2vomni[w] <- sd.xbar(omni2v, rep(n,l-1), "UWAVE-SD")
omni2 <- matrix(out2omni$tnorm[(w):(w+(l-2))], l-1, 1)
mean2omni[w] <- mean(omni2)
std2omni[w] <- sd.xbar.one(omni2, rep(1,l-1), "MR")
}
df <- out2omni$pdist
omni2v <- matrix(df, tmax-1, n, byrow = TRUE)
c1o2v <- list()
for (i in l:(tmax-1)) {
c1o2v[[i-l+1]] <- qcc(omni2v[i,],type = "xbar.one",center = mean2vomni[i-l+1],std.dev = std2vomni[i-l+1], nsigmas=3, plot=FALSE)
}
df <- out2omni$tnorm
omni2 <- matrix(df, tmax-1, 1)
c1o2 <- qcc(omni2[l:(tmax-1)],type = "xbar.one",nsigmas=3, center = mean2omni, std.dev = std2omni, plot=FALSE)
if(plot.figure){
print(plot.qcc(c1o2,title="Control Chart OMNI", l=l))
print(plot.qcc.vertex(c1o2v, l=l,title="Control Chart OMNI"))
}
c1o2v <- list()
for (i in l:(tmax-1)) {
c1o2v[[i-l+1]] <- qcc(omni2v[i,],type = "xbar.one",center = mean2vomni[i-l+1],std.dev = std2vomni[i-l+1], nsigmas=3, plot=FALSE)$violations$beyond.limits
}
result <- list(GraphAD=c1o2$deviation, VertexAD=c1o2v)
return(result)
}else if(method=="MASE"){
#Initialize moving averages and moving standard deviation for GraphAD and VerticesAD
mean2 <- rep(1,(tmax-1)-(l-1))
std2 <- rep(1,(tmax-1)-(l-1))
mean2v <- rep(1,(tmax-1)-(l-1))
std2v <- rep(1,(tmax-1)-(l-1))
if(par){
require(doParallel)
cl <- makeCluster(numpar)
registerDoParallel(cl)
clusterEvalQ(cl, source("cleanutilAD.R"))
clusterExport(cl = cl, varlist = list("ase", "getElbows", "glist",
"elbow", "d","approx", "diag.augment","attrweight"), envir = environment())
out <- foreach(i =1:tmax, .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
latpos <- ase(get.adjacency(glist[[i]], attr=attrweight), d=d, diagaug=diag.augment, approx=approx,elbow=elbow)$Xhat
list(latpos, dim(latpos)[2])
}
stopCluster(cl)
} else {
registerDoSEQ()
out <- foreach(i =1:tmax, .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
latpos <- ase(get.adjacency(glist[[i]], attr=attrweight), d=d, diagaug=diag.augment, approx=approx,elbow=elbow)$Xhat
list(latpos, dim(latpos)[2])
}
}
latpos.list <- out[[1]]
dvec <- unlist(out[[2]])
out2 <- doMase(glist,latpos.list, 2, dsvd, attrweight)
for (w in 1:(tmax-1-(l-1))) {
#Iterative calulating moving averages and moving deviations
mase2v <- t(matrix(out2$pdist[,(w):(w+(l-2))],n,l-1))
mean2v[w] <- mean(mase2v)
std2v[w] <- sd.xbar(mase2v, rep(n,l-1), "UWAVE-SD")
mase2 <- matrix(out2$tnorm[((w):(w+l-2))], l-1, 1)
mean2[w] <- mean(mase2)
std2[w] <- sd.xbar.one(mase2, rep(1,l-1), "MR")
}
df <- out2$pdist
mase2v <- matrix(df, tmax-1, n, byrow = TRUE)
c1m2v <- list()
for (i in l:(tmax-1)) {
c1m2v[[i-l+1]] <- qcc(mase2v[i,],type = "xbar.one",center = mean2v[i-l+1],std.dev = std2v[i-l+1], nsigmas=3, plot=FALSE)
}
df <- out2$tnorm
mase2 <- matrix(df, tmax-1, 1)
c1m2 <- qcc(mase2[l:(tmax-1)],type = "xbar.one",center = mean2 ,std.dev = std2, nsigmas=3, plot=FALSE)
if(plot.figure){
print(plot.qcc(c1m2,title="Control Chart MASE", l=l))
print(plot.qcc.vertex(c1m2v, l=l,title="Control Chart MASE"))
}
c1m2v <- list()
for (i in l:(tmax-1)) {
c1m2v[[i-l+1]] <- qcc(mase2v[i,],type = "xbar.one",center = mean2v[i-l+1],std.dev = std2v[i-l+1], nsigmas=3, plot=FALSE)$violations$beyond.limits
}
result <- list(GraphAD=c1m2$deviation, VertexAD=c1m2v)
return(result)
}
}
glist <- list()
for (i in 1:5) {
glist[[i]] <- sample_gnp(100,.1)
}
glist[[6]] <- sample_gnp(100,.6)
glist[[7]] <- sample_gnp(100,.3)
for (i in 8:12) {
glist[[i]] <- sample_gnp(100,.1)
}
l=4
d=1
dsvd=1
result<- qccAD(glist, method="OMNI", diag.augment = TRUE, l,d, dsvd, approx=FALSE, par=FALSE, numpar=2)
source("cleanutilAD.R")
#' Function to perform anomaly detection for time series of graphs
#' @param glist: a list of undirected simple graphs (simple graphs are graphs which do not contain self-loop and multiple edges)
#' in igraph format with same number of vertices with vertices are 1-1 matched.
#' Graphs can be weighted or binary. (Say the length of list to be tmax)
#' @param method: A character variable  to be chosen among c("OMNI","MASE"). The code will first do OMNIbus embedding (OMNI) or Multiple Adjacency Spectrally Ebedding (MASE) with two adjcaency matrices(can be weighted or not) of all input adjacent graphs sequentially. Then use latent positions to calculate test statistics y^{t}=||X^{t}- X^{t+1}|| using operator norm. Then for t=l,...,tmax-1, we calculate the moving means $mu^t$ and moving standard deviations $simgma^t$ at t by y^{t-l+1},...,y^{t-1}.
#' @param d: A fixed integer of dimension to perform OMNI and individual ASE for MASE.  If d is NULL, then dimension is chosen automatically.
#' @param l: An integer of the number of graphs in time window in estimating the moving mean and moving standard deviation. If l is greater or equal than number of graphs then it outputs an error. l has to be strictly greater than 3.
#' @param approx: A Boolean variable approx to decide whether to use irlba package to perform svd. Default is TRUE.
#' @param diag.augment: A Boolean variable diag.augment to decide whether to do diagonal augmentation when performing adjacency spectral embedding. Default is TRUE.
#' @param par: A Boolean variable par to decide whether to run in parallel. Default is FALSE.
#' @param numpar: An integer number to decide number of clusters for parallel implmentation. Default is 2.
#' @param dsvd: An integer number of dimension only used in joint embedding for MASE. If NULL, then dimension is chosen automatically as second elbow selected in Zhu & Ghodsi method for the scree plot of the singular values of the concatenated spectral embeddings of MASE.
#' @param elbow: number of elbow in Zhu & Ghodsi method for the scree plot of each individual graph singular values for MASE or of each omnibus matrix singular values for OMNI.
#' @param plot.figure: A Boolean variable to decide whether plot control chart. Default is TRUE.
#' @return A list containing a vector GraphAD of length tmax-l which consists of control charts deviations, with the
#' a list VertexAD (length tmax-l) with vectors of anomalous vertices indices for each graph.
qccAD <- function(glist, method="OMNI", diag.augment = TRUE, l,d, dsvd, approx=TRUE, par=FALSE, numpar=2, elbow=2, plot.figure=TRUE){
tmax <- length(glist)
n <- vcount(glist[[1]])
tvec <- 1:tmax
m2 <- names(running(tvec, width=2))
#check if all the graphs are binary
if(Reduce("+",lapply(glist, function(x) is.weighted(x)))){
attrweight <- "weight"
}else{
attrweight <- NULL
}
if(l>(tmax-1)||l<3||tmax<4){
print(paste0("l has to an integer between 3 and ",tmax-1, " and you need to at least have 4 graphs"))
}
require(foreach)
if (method=="OMNI"){
#Initialize moving averages and moving standard deviation for GraphAD and VerticesAD
mean2omni <- rep(1, (tmax-1)-(l-1))
std2omni <- rep(1,(tmax-1)-(l-1))
mean2vomni <- rep(1, (tmax-1)-(l-1))
std2vomni <- rep(1,(tmax-1)-(l-1))
if(par){
require(doParallel)
cl <- makeCluster(numpar)
registerDoParallel(cl)
clusterEvalQ(cl, source("cleanutilAD.R"))
clusterExport(cl = cl, varlist = list("ase", "fast2buildOmni", "getElbows", "glist",
"elbow", "d","approx", "diag.augment","attrweight"), envir = environment())
allomni <- foreach(i =1:(tmax-1), .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
O <- fast2buildOmni( glist[i:(i+1)]  , diagaug=diag.augment, attrweight=attrweight)
a <- ase(O, d=d, diagaug=FALSE, approx=approx,elbow=elbow)
list(a, a$d)
}
stopCluster(cl)
} else {
registerDoSEQ()
allomni <- foreach(i =1:(tmax-1), .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
O <- fast2buildOmni( glist[i:(i+1)]  , diagaug=diag.augment, attrweight=attrweight)
a <- ase(O, d=d, diagaug=FALSE, approx=approx,elbow=elbow)
list(a, a$d)
}
}
a = allomni[[1]]
out2omni <- fast2doOmni(glist, omniase=a)
for (w in 1:(tmax-1-(l-1))) {
#Iterative calulating moving averages and moving deviations
omni2v <- t(out2omni$pdist[,(w):(w+(l-2))])
mean2vomni[w] <- mean(omni2v)
std2vomni[w] <- sd.xbar(omni2v, rep(n,l-1), "UWAVE-SD")
omni2 <- matrix(out2omni$tnorm[(w):(w+(l-2))], l-1, 1)
mean2omni[w] <- mean(omni2)
std2omni[w] <- sd.xbar.one(omni2, rep(1,l-1), "MR")
}
df <- out2omni$pdist
omni2v <- matrix(df, tmax-1, n, byrow = TRUE)
c1o2v <- list()
for (i in l:(tmax-1)) {
c1o2v[[i-l+1]] <- qcc(omni2v[i,],type = "xbar.one",center = mean2vomni[i-l+1],std.dev = std2vomni[i-l+1], nsigmas=3, plot=FALSE)
}
df <- out2omni$tnorm
omni2 <- matrix(df, tmax-1, 1)
c1o2 <- qcc(omni2[l:(tmax-1)],type = "xbar.one",nsigmas=3, center = mean2omni, std.dev = std2omni, plot=FALSE)
if(plot.figure){
print(plot.qcc(c1o2,title="Control Chart OMNI", l=l))
print(plot.qcc.vertex(c1o2v, l=l,title="Control Chart OMNI"))
}
c1o2v <- list()
for (i in l:(tmax-1)) {
c1o2v[[i-l+1]] <- qcc(omni2v[i,],type = "xbar.one",center = mean2vomni[i-l+1],std.dev = std2vomni[i-l+1], nsigmas=3, plot=FALSE)$violations$beyond.limits
}
result <- list(GraphAD=c1o2$deviation, VertexAD=c1o2v)
return(result)
}else if(method=="MASE"){
#Initialize moving averages and moving standard deviation for GraphAD and VerticesAD
mean2 <- rep(1,(tmax-1)-(l-1))
std2 <- rep(1,(tmax-1)-(l-1))
mean2v <- rep(1,(tmax-1)-(l-1))
std2v <- rep(1,(tmax-1)-(l-1))
if(par){
require(doParallel)
cl <- makeCluster(numpar)
registerDoParallel(cl)
clusterEvalQ(cl, source("cleanutilAD.R"))
clusterExport(cl = cl, varlist = list("ase", "getElbows", "glist",
"elbow", "d","approx", "diag.augment","attrweight"), envir = environment())
out <- foreach(i =1:tmax, .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
latpos <- ase(get.adjacency(glist[[i]], attr=attrweight), d=d, diagaug=diag.augment, approx=approx,elbow=elbow)$Xhat
list(latpos, dim(latpos)[2])
}
stopCluster(cl)
} else {
registerDoSEQ()
out <- foreach(i =1:tmax, .combine='comb', .multicombine=TRUE,.packages = "igraph",
.init=list(list(), list())) %dopar% {
latpos <- ase(get.adjacency(glist[[i]], attr=attrweight), d=d, diagaug=diag.augment, approx=approx,elbow=elbow)$Xhat
list(latpos, dim(latpos)[2])
}
}
latpos.list <- out[[1]]
dvec <- unlist(out[[2]])
out2 <- doMase(glist,latpos.list, 2, dsvd, attrweight)
for (w in 1:(tmax-1-(l-1))) {
#Iterative calulating moving averages and moving deviations
mase2v <- t(matrix(out2$pdist[,(w):(w+(l-2))],n,l-1))
mean2v[w] <- mean(mase2v)
std2v[w] <- sd.xbar(mase2v, rep(n,l-1), "UWAVE-SD")
mase2 <- matrix(out2$tnorm[((w):(w+l-2))], l-1, 1)
mean2[w] <- mean(mase2)
std2[w] <- sd.xbar.one(mase2, rep(1,l-1), "MR")
}
df <- out2$pdist
mase2v <- matrix(df, tmax-1, n, byrow = TRUE)
c1m2v <- list()
for (i in l:(tmax-1)) {
c1m2v[[i-l+1]] <- qcc(mase2v[i,],type = "xbar.one",center = mean2v[i-l+1],std.dev = std2v[i-l+1], nsigmas=3, plot=FALSE)
}
df <- out2$tnorm
mase2 <- matrix(df, tmax-1, 1)
c1m2 <- qcc(mase2[l:(tmax-1)],type = "xbar.one",center = mean2 ,std.dev = std2, nsigmas=3, plot=FALSE)
if(plot.figure){
print(plot.qcc(c1m2,title="Control Chart MASE", l=l))
print(plot.qcc.vertex(c1m2v, l=l,title="Control Chart MASE"))
}
c1m2v <- list()
for (i in l:(tmax-1)) {
c1m2v[[i-l+1]] <- qcc(mase2v[i,],type = "xbar.one",center = mean2v[i-l+1],std.dev = std2v[i-l+1], nsigmas=3, plot=FALSE)$violations$beyond.limits
}
result <- list(GraphAD=c1m2$deviation, VertexAD=c1m2v)
return(result)
}
}
glist <- list()
for (i in 1:5) {
glist[[i]] <- sample_gnp(100,.1)
}
glist[[6]] <- sample_gnp(100,.9)
glist[[7]] <- sample_gnp(100,.1)
for (i in 8:12) {
glist[[i]] <- sample_gnp(100,.1)
}
l=4
d=1
dsvd=1
result<- qccAD(glist, method="OMNI", diag.augment = TRUE, l,d, dsvd, approx=FALSE, par=FALSE, numpar=2)
getwd()
d <- document::document(file_name = "/Users/guodongchen/Documents/R/cleanutilAD.R", check_package = FALSE)
install.packages("document")
d <- document::document(file_name = "/Users/guodongchen/Documents/R/cleanutilAD.R", check_package = FALSE)
d <- document::document(file_name = "/Users/guodongchen/Documents/R/cleanutilAD.R", check_package = FALSE)
d <- document::document(file_name = cat(readLines("/Users/guodongchen/Documents/R/cleanutilAD.R"), sep = "\n"), check_package = FALSE)
d <- document::document(file_name = "/Users/guodongchen/Documents/R/cleanutilAD.R", check_package = FALSE)
system.file("files", "minimal.R", package = "document")
path <- system.file("/Users/guodongchen/Documents/R/", "cleanutilAD.R", package = "document")
path
cat(readLines(path), sep = "\n")
path <- system.file("R", "cleanutilAD.R", package = "document")
cat(readLines(path), sep = "\n")
path <- system.file("files", "cleanutilAD.R", package = "document")
path
path <- system.file("files", "cleanutilAD.R")
path
d <- document::document(file_name = "/Users/guodongchen/Documents/R/cleanutilAD.R", check_package = FALSE)
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE)
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE)
tempdir()
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d
source("cleanAD.R")
glist <- list()
for (i in 1:5) {
glist[[i]] <- sample_gnp(100,.1)
}
glist[[6]] <- sample_gnp(100,.9)
glist[[7]] <- sample_gnp(100,.1)
for (i in 8:12) {
glist[[i]] <- sample_gnp(100,.1)
}
l=4
d=1
dsvd=1
result<- qccAD(glist, method="OMNI", diag.augment = TRUE, l,d, dsvd, approx=FALSE, par=FALSE, numpar=2)
source("cleanutilAD.R")
glist <- list()
for (i in 1:5) {
glist[[i]] <- sample_gnp(100,.1)
}
glist[[6]] <- sample_gnp(100,.9)
glist[[7]] <- sample_gnp(100,.1)
for (i in 8:12) {
glist[[i]] <- sample_gnp(100,.1)
}
l=4
d=1
dsvd=1
result<- qccAD(glist, method="OMNI", diag.augment = TRUE, l,d, dsvd, approx=FALSE, par=FALSE, numpar=2)
source("cleanutilAD.R")
glist <- list()
for (i in 1:5) {
glist[[i]] <- sample_gnp(100,.1)
}
glist[[6]] <- sample_gnp(100,.9)
glist[[7]] <- sample_gnp(100,.1)
for (i in 8:12) {
glist[[i]] <- sample_gnp(100,.1)
}
l=4
d=1
dsvd=1
result<- qccAD(glist, method="OMNI", diag.augment = TRUE, l,d, dsvd, approx=FALSE, par=FALSE, numpar=2)
result$GraphAD
result$VertexAD
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d <- document::document(file_name = "cleanutilAD.R", check_package = FALSE, output_directory = getwd())
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd())
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD")
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD")
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD")
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD")
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD")
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD")
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD")
d <- document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD")
source('~/Documents/R/utilAD.R', echo=TRUE)
devtools::document()
document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD", runit=FALSE)
document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD", runit=FALSE)
document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD", runit=FALSE,begin_pattern = "ROXYGEN_123")
document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd(),dependencies="TSGAD", runit=FALSE)
document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd())
document::document(file_name = "utilAD.R", check_package = FALSE, output_directory = getwd())
require(knitr)
stitch("example.R")
library(AnomalyDetection)
require(knitr)
stitch("example.R")
setwd("~/Documents/R/AnomalyDetection")
require(knitr)
stitch("example.R")
library(AnomalyDetection)
library(AnomalyDetection)
detach("package:AnomalyDetection", unload = TRUE)
getwd()
library(AnomalyDetection)
library(AnomalyDetection)
detach("package:AnomalyDetection", unload = TRUE)
